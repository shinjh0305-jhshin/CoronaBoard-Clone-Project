api의 프로그램 구조에 관한 설명

1. index.js는 API의 대문 역할을 한다.
    node index.js 명령을 통해서 API의 시동을 걸 수 있다.
    이 때, API가 잘 실행되었는지를 사용자에게 콘솔에서 알려준다.
    HTTP 요청이 특정 주소로 오면 어떤 컨트롤러로 갈지 정해주며(라우팅)
    컨트롤러는 require를 통해서 모듈로서 추가된다.
    마지막으로 sequelize를 실행해서 DB와 객체 모델의 연결을 활성화한다.

2. util.js는 컨트롤러를 try-catch 문으로 감싸서 에러 처리를 한다.
    컨트롤러가 생길 때 마다 모든 함수에 똑같이 정의할 try-catch문을 반복적으로 작성하는 것은 비효율적이기에
    하나의 래핑 매개함수 및 래핑함수를 통해서 에러 처리를 한다.

3. database 폴더 내에는 sequelize(ORM 모듈)에서 이용할 객체 모델이 있다.
    ORM은 DB의 쿼리 명령문을 작성하지 않고, 라이브러리의 메서드에 의존해서 인스턴스를 수정하는 것과 유사하게 DB에 접근한다.

    index.js에는 DB에 접근하기 위한 모든 접근 정보가 들어 있다.
    또, DB의 어떤 스키마와 객체 모델의 어떤 인스턴스를 연결지을지를 알려주는 객체 모델이 require문으로 들어와 있다.

    특히 아래와 같은 객체를 외부에 제공한다.

    -sequelize 객체 : DB의 접근에 필요한 모든 정보가 들어 있으며, 1번의 index.js가 API의 시동을 걸 때, sequelize 객체와 DB를 연결시켜준다.

    -GlobalStat, KeyValue 데이터 모델 : 컨트롤러 js 파일에 가서 모델과 컨트롤러를 연결시켜주기 위해서 모듈로 공개한다. 이 때, 모델을 만드는 과정에서 모델이 저장 될 객체가 필요하기 때문에, sequelize를 매개변수로 model.js 파일들한테 전달해준다.

    model.js에는 DB에 입력되는 정보에 대한 제한조건과 만들어진 객체 모델을 리턴해서 전달받은 sequelize 객체에 저장하는 역할을 수행하는 define 문이 들어가 있다.
    중요한 점은 DB에는 반드시 데이터 모델을 매개로 해서 접근해야 한다는 것이다. 데이터 모델은 데이터 형식의 제한 기능만 수행하는 것이 아닌, 어느 데이터 필드에 데이터를 매칭시켜야 하는지에 대한 정보까지 들어 있다.

4. controller 폴더 내에는 말 그대로 http 요청이 들어왔을 때, 수행 할 함수에 대한 정보가 들어있다. 
    ORM 데이터 모델에서 제공하는 메서드를 이용해서 정보의 CRUD를 구현한다.
    특히 에러 처리 함수를 require해서 마지막에 래핑해서 컨트롤러를 내보내는 특징이 있다.

    